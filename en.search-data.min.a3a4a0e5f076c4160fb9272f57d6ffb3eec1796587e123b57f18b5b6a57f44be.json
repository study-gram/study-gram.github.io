[{"id":0,"href":"/docs/HTTP-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/I.-HTTP-%EC%9B%B9%EC%9D%98-%EA%B8%B0%EC%B4%88/01.HTTP-%EA%B0%9C%EA%B4%80/","title":"01. HTTP 개관","section":"I. HTTP 웹의 기초","content":"HTTP 개관 #  작성자 jaewon0913\n 1.1 HTTP: 인터넷의 멀티미디어 배달부 #  HTTP란? #   전 세계의 웹 서버로부터 대량의 정보(이미지, HTML 페이지, 텍스트 파일, 동영상 등)를 빠르고, 간편하고, 정확하게 사람들의 PC에 설치된 웹 브라우저로 옮겨준다. 신뢰성 있는 데이터 전송 프로토콜을 사용하므로 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장한다.  1.2 웹 클라이언트와 서버 #  웹 서버란? #   인터넷의 데이터를 저장하고, HTTP 클라이언트가 요청한 데이터를 제공한다. 웹 서버는 HTTP 프로토콜로 통신하기 때문에 보통 HTTP 서버라고도 불린다. 웹 리소스를 관리하고 제공한다.   웹 클라이언트란? #   서버에게 HTTP 객체를 요청하고 사용자에게 해당 데이터/화면을 보여준다. 보통 사용자가 사용하는 구글 크롬, 인터넷 익스플로러가 웹 클라이언트이다.  1.3 리소스 #  리소스란? #   웹 콘텐츠의 원천이다. 요청에 따라 콘텐츠를 생성하는 프로그램이 될 수 있다. 텍스트파일, HTML파일, 워드 파일, 이미지, 동영상 등 모든 종류의 파일 및 콘텐츠 소스도 포함된다.   미디어타입\n  HTTP 는 수천 개의 데이터 타입을 다루기 때문에 MIME(Multipurpose Internet Mail Extensions, 다목적 인터넷 메일 확장) 라는 데이터 포맷 라벨을 웹에서 전송되는 객체 각각에 붙인다. 즉 이 웹 콘텐츠가 어떤 데이터 타입인지 알려주는 라벨이다. 웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다. 표현 형식: \u0026lsquo;주 타입/부 타입\u0026rsquo;  HTML 데이터 타입 = \u0026ldquo;text/html\u0026rdquo; JPEG 이미지 데이터 타입 = \u0026ldquo;image/jpeg\u0026rdquo; GIF 이미지 데이터 타입 = \u0026ldquo;image/gif\u0026rdquo;     URI\n  URI(Uniform Resource Identifier, 통합 자원 식별자)는 서버 리소스 이름이라고도 불린다. 인터넷의 우편물 주소 같은 역할로 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.    URL\n  URL(Uniform Resource Locator, 통합 자원 지시자)는 리소스 식별자의 가장 흔한 형태이다. 특정 서버의 한 리소스에 대한 구체적인 위치를 서술한다. 오늘날 대부분 URI는 URL이다. 표현은 세 부분으로 이루어진 표준 포맷을 따른다.  첫 번째, 스킴(Scheme) 이라고 불리며, 리소스에 접근하기 위해 사용되는 프로토콜을 서술한다.(ex: http://) 두 번째, 서버의 인터넷 주소를 제공한다.(ex: www.study-gram.com) 세 번재, 웹 서버의 리소스를 가리킨다.(ex: /images/apple.jpg)     URN\n  URN(Uniform Resource Name, 유니폼 리소스 이름)은 URI 의 두 번재 종류이다. 리소스의 위치에 영향을 받지 않는 유일무이한 이름 역할을 한다.  1.4 트랜잭션 #   트랜잭션은 요청(Request) 명령(클라이언트 -\u0026gt; 서버)과 응답(Response) 결과(서버 -\u0026gt; 클라이언트)로 구성되어 있다.   메소드(method)\n  HTTP 는 HTTP 메서드라고 불리는 여러 가지 종류의 요청 명령을 지원한다. 모든 요청 메세지는 1 개의 메소드를 갖는다.     HTTP 메소드 설명     GET 서버에서 클라이언트로 지정한 리소스를 보내라   PUT 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스를 저장하라   DELETE 지정한 리소스를 서버에서 삭제해라   POST 클라이언트 데이터를 서버 게이트웨이 어플리케이션으로 보내라   HEAD 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라     상태 코드\n  클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 3자리 숫자이다.(3장에서 상세히 다)     HTTP 상태코드 설명     200 성공   404 리소스를 찾을수 없음   500 서버 에러    1.5 메시지 #   HTTP 메시지는 단순한 줄 단위의 문자열이다. Client -\u0026gt; Server 로 보낸 HTTP 메시지를 요청 메시지라 한다. Server -\u0026gt; Client 로 보낸 HTTP 메시지를 응답 메시지라 한다. 구성은 아래와 같다.  시작줄  요청 및 응답애 대한 내용   헤더  0개 이상의 헤더 필로 구성 쌍점(:)으로 구분되어 하나의 이름과 하나의 값으로 구성 빈 줄로 끝남   본문  어떤 종류의 데이터든 들어갈 수 있는 메시지 본문 요청: 웹 서버로 데이터를 실어보냄 응답: 클라이언트로 데이터 반환 텍스트 이외에 임의의 이진 데이터 포함 가능(이미지, 비디오, 오디오 등)      1.6 TCP 커넥션 #   TCP/IP\n  TCP(Transmission Control Protocol, 전송 제어 프로토콜)  오류 없는 데이터 전송 순서에 맞는 전달(데이터는 언제나 보낸 순서대로 도착) 조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있음)   TCP/IP  패킷 교환 네트워크 프로토콜의 집합 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터/네트워크든 서로 신뢰성 있는 의사소통을 가능하게 함 일단 TCP 커넥션이 맺어지면, 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상되거나 하는 일은 없다.     접속, IP 주소 그리고 포트번호\n  HTTP 메시지를 전송하기 위해서는 IP 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 함 표현 방식 : \u0026ldquo;IP주소:포트번호\u0026rdquo;(ex: http://127.0.0.1:8080) 클라이언트와 서버 사이의 통신 순서  웹 브라우저는 서버의 URL 에서 호스트 명을 추출 서버의 호스트 명을 IP로 변환 URL에서 포트번호를 추출 웹 서버와 TCP 커넥션을 맺음 클라이언트는 서버에 HTTP 요청을 보냄 서버는 클라이언트에 HTTP 응답을 보냄 커넥션이 닫히면, 웹 브라우저는 문서를 보여줌    1.7 프로토콜 버전 #   HTTP/1.0 : 처음으로 널리 쓰이기 시작한 HTTP 버전 HTTP/1.1 : HTTP 설계의 구조적 결함 교정, 성능 최적화, 잘못된 기능 제거에 집중한 현재의 HTTP 버전 HTTP/2.0 : HTTP/1.1 성능 문제를 개선한 HTTP 버전(10장에서 자세히 다룸)  1.8 웹의 구성요소 #     이름 설명     프락시 클라이언트와 서버 사이에 위치한 HTTP 중개자   캐시 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고   게이트웨이 다른 애플리케이션과 연결된 특별한 웹 서버   터널 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시   에이전트 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트    "},{"id":1,"href":"/docs/HTTP-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/I.-HTTP-%EC%9B%B9%EC%9D%98-%EA%B8%B0%EC%B4%88/02.URL-%EA%B3%BC-%EB%A6%AC%EC%86%8C%EC%8A%A4/","title":"02. URL 과 리소스","section":"I. HTTP 웹의 기초","content":"URL 과 리소스 #  작성자 nice7677\n 2.1 인터넷의 리소스 탐색하기 #  URL(Uniform Resource Locator)은 인터넷의 리소스를 가리키는 표준이름이다.\nURL은 전자정보 일부를 가리키고 그것이 어디에 있고 어떻게 접근할 수 있는지 알려준다.\nURL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리킨다.\nURL은 통합 자원 식별자(Uniform Resource Indentifier) 혹은 URI라고 불리는 더 일반화된 부류의 부분집합이다.\nURN(Uniform Resource Name)은 현재 그 리소스가 어디에 존재하든 상관없이 그 이름만으로 리소스를 식별하는데 비해 URL은 리소스가 어디 있느지 설명해서 리소스를 식별한다.\n이 셋의 관계를 그림으로 보면 아래와 같다.\n 참조 및 이미지 - The Real Difference Between a URL and a URI\n다음과 같은 URL이 있다고 할때\nhttps://study.springboot.kr/docs/HTTP-완벽가이드/I.-HTTP-웹의-기초/02.URL과-리소스/\nURL의 첫 부분인 https는 URL의 스킴, URL 두번째 부분인 study.springboot.kr은 서버의 위치이고 URL의 세번째 부분인 /docs/HTTP-완벽가이드/I.-HTTP-웹의-기초/02.URL과-리소스/는 리소스의 경로다.\n각 부분의 역할을 보면\n 스킴(scheme) - 웹 클라이언트가 리소스에 어떻게 접근하는지 알려준다.  ex) https, ftp, rtsp   서버의 위치 - 웹 클라이언트가 리소스가 어디에 호스팅 되어 있는지 알려준다. 리소스의 경로 - 서버에 존재하는 로컬 리소스들 중에서 요청받은 리소스가 무엇인지 알려준다.  아래의 그림을 한번보고 넘어가길 바란다.\n 참조 및 이미지 - What is a URL?\n2.2 URL 문법 #  URL의 문법을 쪼개면 일반적으로 9개의 부분으로 나뉘게 된다\n  참조 및 이미지 - URLs and URIs\n 스킴 사용자 이름 비밀번호 호스트 포트 경로 파라미터 질의 프래그먼트  2.3 단축 URL #  상대 URL은 짧게 표기하는 방식이다.\n상대 URL 문법에 따르면 HTML 작성자는 URL에 스킴과 호스트 그리고 다른 컴포넌트들을 입력하지 않아도 된다.\n예로 현재 사이트에서 다음과 같은 코드를 사용 할 경우\n\u0026lt;img src=\u0026#34;./hi.png\u0026#34;\u0026gt; 기저 URL을 사용해 기술하지 않은 정보를 추측할 수 있다.\n기저 URL을 사용하게 되면 절대 URL은 https://study.springboot.kr/hi.png 가 된다.\n2.4 안전하지 않은 문자 #  다음의 글로 대체 합니다.\n What is URL Encoding and How does it work?\n2.5 스킴의 바다 #  다음의 위키피디아 문서로 대체 합니다.\n List_of_URI_schemes\n"},{"id":2,"href":"/docs/HTTP-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/I.-HTTP-%EC%9B%B9%EC%9D%98-%EA%B8%B0%EC%B4%88/03.HTTP-%EB%A9%94%EC%8B%9C%EC%A7%80/","title":"03. HTTP 메시지","section":"I. HTTP 웹의 기초","content":"HTTP 메시지 #  작성자 jaewon0913\n 3.1 메시지의 흐름 #   HTTP 메시지는 HTTP 어플리케이션 간에 주고받은 데이터의 블록들이다. 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다. 메시지는 클라이언트, 서버, 프락시 사이를 흐른다. 인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미한다.  3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다. #   인바운드 : 메시지가 원 서버로 향하는 이동 아웃바운드 : 모든 처리가 끝나고 뒤에 메시지가 사용자 에이전트로 돌아오는 것  3.1.2 다운스트림으로 흐르는 메시지 #   모든 메시지는 다운스트림으로 흐름 메시지의 발송자는 수신자의 업스트림이 됨   3.2 메시지의 각 부분 #   HTTP 메시지는 단순한, 데이터의 구조화된 블록이다. 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다. 메시지는 시작줄, 헤더 블록, 본문 으로 구성된다.  시작줄, 헤더 블록  줄 단위로 분리된 아스키(ASCII) 문자열이다. 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다.   본문  선택적인 데이터 덩어리이다. 텍스트나 이진 데이터를 포함할 수 있고, 그냥 비어 있을 수 있다.      메시지 문법 #   요청, 응답 메시지 구조는 동일하나 시작줄에만 문법이 다르다.  요청메시지 형식 \u0026lt;메서드\u0026gt; \u0026lt;요청 URL\u0026gt; \u0026lt;버전\u0026gt; \u0026lt;헤더\u0026gt;  \u0026lt;엔티티 본문\u0026gt;  응답메시지 형식 \u0026lt;버전\u0026gt; \u0026lt;상태 코드\u0026gt; \u0026lt;사유 구절\u0026gt; \u0026lt;헤더\u0026gt;  \u0026lt;엔티티 본문\u0026gt;        각 부분 설명     메서드 클라이언트 측에서 서버가 리소스에 대해 행해주길 바라는 동작을 의미한다.\u0026lsquo;GET\u0026rsquo;,\u0026lsquo;HEAD\u0026rsquo;,\u0026lsquo;POST\u0026rsquo; 와 같이 한 단어로 구성된다.   요청 URL 요청 대상이 되는 리소스를 지칭한다.   버전 메시지에서 사용 중인 HTTP의 버전이다.형식 : HTTP/\u0026lt;메이저\u0026gt;.\u0026lt;마이너\u0026gt;   상태코드 요청 중에 무엇이 일어났는지 설명해주는 세 자리의 숫자이다.각 코드의 첫 번재 자릿수는 상태의 일반적인 분류(\u0026lsquo;성공\u0026rsquo;,\u0026lsquo;에러\u0026rsquo; 등)를 나타낸다.   사유구절 숫자로 된 상태코드의 의미를 이해할수 있게 설명해주는 짧은 문구이다.   헤더들 이름,콜론(:),선택적인 공백, 값, CRLF 가 순서대로 나타나는 0개 이상의 헤더이다.   엔티티 본문 임의의 데이터 블록을 포함한다.모든 메시지가 갖는 것이 아니므로 종종 CRLF 로 끝나는 경우도 있다.    시작줄 #   모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지에서는 무엇을 해야 하는지를, 응답 메시지에서는 무슨 일이 일어났는지 알려준다. 요청줄  서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지정하는 요청 URL이 들어있다. 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다.   응답줄  수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.   메서드  HTTP 명세는 공통 요청 메서드의 집합을 정의한다. 요청 메시지에 따라 본문이 있을 수도 있고 없을 수도 있다.   상태코드  클라이언트에게 무엇이 일어났는지 말해준다. 각 응답메시지의 시작줄에 담겨 반환한다.   사유 구절  응답 시작줄의 마지막 구성요소이다. 상태 코드에 대한 글로 된 설명을 제공한다. 숫자로 된 상태코드 + 문자열로 된 사유구절이 일대일 대응한다.   버전 번호  HTTP 어플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다. HTTP 로 대화하는 어플리케이션들에게 대화 상대의 능력과 메시지의 형식에 대한 단서를 제공해주기 위한 것이다.    헤더 #   요청과 응답 메시지에 추가 정보를 더한다.  헤더 분류  일반 헤더 : 요청과 응답 양쪽에 모두 나타날 수 있음. 요청 헤더 : 요청에 대한 부가 정보를 제공. 응답 헤더 : 응답에 대한 부가 정보를 제공. Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술. 확장 헤더 : 명세애 정의되지 않은 새로운 헤더.      엔티티 본문 #   HTTP 메시지의 세번째 부분은 선택적인 엔터티 본문 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.  3.3 메서드 #   메서드 구분     메서드 설명 본문 포함 여부     GET 서버에서 어떤 문서를 가져온다. X   HEAD 서버에서 어떤 문서에 대해 헤더만 가져온다. X   POST 서버가 처리해야하 할 데이터를 보낸다. O   PUT 서버에 요청 메시지의 본문을 저장한다. O   TRACE 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다. X   OPTIONS 서버가 어떤 메서드를 수행할 수 있는지 확인한다. X   DELETE 서버에서 문서를 제거한다. X    3.4 상태 코드 #   상태코드 구분     상태코드 범위 분류     100 ~ 199 100 ~ 101 정보   200 ~ 299 200 ~ 206 성공   300 ~ 399 300 ~ 305 리다이렉션   400 ~ 499 400 ~ 415 클라이언트 에러   500 ~ 599 500 ~ 505 서버 에러    "},{"id":3,"href":"/docs/HTTP-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/II.-HTTP-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/04.%EC%BB%A4%EB%84%A5%EC%85%98-%EA%B4%80%EB%A6%AC/","title":"04.커넥션 관리","section":"Ii. HTTP 아키텍처","content":"커넥션 관리 #  작성자 nice7677\n 4.1 TCP 커넥션 #  HTTP 통신은 TCP/IP 위에서 이루어 지며 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고받는 메세지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다. (예외 HTTP3는 UDP 간단한 설명은 다음을 읽어보자 위키피디아 - HTTP/3)\nTCP는 신뢰할 수 있는 데이터 전송 통로이며 HTTP에게 신뢰할 만한 통신 방식을 제공하며 TCP 스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.\n  참조 - How HTTP request passes through OSI layers for communicating the web server?\n그림에서 볼 수 있듯이 HTTPS는 HTTP에 TLS 나 SSL(보안 계층)을 추가한 것이다.\nHTTP가 메시지를 전송하고자 할 경우 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터를 순서대로 보낸다. TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다.\nIP 패킷들 각각은 다음을 포함한다.\n IP 패킷 헤더(보통 20바이트) TCP 세그먼트 헤더(보통 20바이트) TCP 데이터 조각(0 혹은 그 이상의 바이트)  IP 헤더는 발신자와 목적지 IP 주소, 크기, 기타 플래그를 가진다. TCP 세그머느 헤더는 TCP 포트 번호, TCP 제어 플래그, 그리고 데이터의 순서와 무결성을 검사하기 위해 사용되는 숫자 값을 포함한다.\n TCP 커넥션은 네가지 값으로 식별한다.\n\u0026lt;발신지 IP 주소, 발신지 포트, 수신지 IP 주소, 수신지 포트\u0026gt;\n이 네 가지 값으로 유일한 커넥션을 생성한다. 서로 다른 두 개의 TCP 커넥션은 네가지 주소 구성요소의 값이 모두 같은 수 없다.\n   커넥션 발신지 IP 주소 발신지 포트 발신지 포트 발신지 포트     A 209.1.32.34 2034 204.62.128.58 4133   B 209.1.32.35 3227 204.62.128.58 4140   C 209.1.32.35 3105 207.25.71.25 80   D 209.1.33.89 5100 207.25.71.25 80     위의 그림에서 볼 수 있듯이 커넥션 구성요소를 모두 똑같이 가리키고 있는 커넥션은 있을 수 없다.\n4.2 TCP의 성능에 대한 고려 #  HTTP는 TCP 바로 위에 있기 때문에 TCP 성능에 영향을 받는다. 그렇기 때문에 TCP에 대해 자세히 알아야 한다.\n! TCP 기본 영상으로 다음 영상을 한번 보면 도움이 될거습니다.\n [10분 테코톡] 👨‍🏫르윈의 TCP UDP\n4.3 HTTP 커넥션 관리 #  HTTP 커넥션의 성능을 향상시킬 수 있는 여러 기술이 있다.\n그중 병렬 커넥션과 지속 커넥션에 대한 장단점을 알아보자.\n 병렬 커넥션(parallel) - 여러 개의 커넥션을 맺음으로써 여러개의 트랜잭션을 병렬로 처리할 수 있게 한다.  장점  각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있다. 병렬로 내려받아 커넥션 지연이 겹쳐짐으로써 총 지연시간이 줄어든다.   단점  네트워크 대역폭이 좁을 때 느리다. 다수의 커넥션은 메모리를 많이 소모하고 성능 문제를 발생시킨다. 커넥션의 수에 제한이 있다.     지속 커넥션(persistent) - 연결 후에도 TCP 커넥션을 유지해 앞으로 있을 요청에 재사용할 수 있다.  장점  커넥션을 맺기 위한 사전 작업과 지연을 줄여 준다. 튜닝된 커넥션을 유지할 수 있다.   단점  잘못 관리할 경우 계속 연결된 상태로 있는 수많은 커넥션이 쌓이게 되어 불필요한 서버와 클라이언트 리소스에 불필요한 소모를 발생시킨다.      지속 커넥션과 병렬 커넥션이 함께 사용될 때에 가장 효과적이다.\n같이 보면 좋은 글\n HTTP Keep Alive 알아보기\n"},{"id":4,"href":"/docs/HTTP-%EC%99%84%EB%B2%BD%EA%B0%80%EC%9D%B4%EB%93%9C/II.-HTTP-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/05.%EC%9B%B9-%EC%84%9C%EB%B2%84/","title":"05.웹 서버","section":"Ii. HTTP 아키텍처","content":"웹 서버 #  작성자 jaewon0913\n 5.1 다채로운 웹 서버 #   웹 서버는 HTTP 요청하고 처리하고 응답을 제공한다. 웹 서버 소프트웨어와 웹페이지 제공에 특화된 장비 양쪽 모두를 가리킨다.  5.1.1 웹 서버 구현 #   웹 서버는 HTTP 및 그 와 관련된 TCP 처리를 구현한 것이다. 웹 서버는 HTTP 프로토콜을 구현하고, 웹 리소스를 관리하고, 웹 서버 관리 기능을 제공한다. 웹 서버는 여러가지 형태가 가능하다.  다목적 소프트웨어 웹 서버를 표준 컴퓨터 시스템에 설치하고 실행할 수 있다. 종종 어떤 회사들은 사용자에게 판매할 전자기기 안에 몇 개의 컴퓨터 칩만으로 구현된 웹 서버를 내장시켜서 완전한 관리 콘솔로 제공하기도 한다.    5.1.2 다목적 소프트웨어 웹 서버 #   다목적 소프트웨어 웹 서버는 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다. 웹 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작한다.  5.1.3 임베디드 웹 서버 #   임베디드 웹 서버는 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버이다. 사용자가 가들의 일반 소비자용 기기를 간편한 웹 브라우저 인터페이스로 관리할 수 있게 한다.  5.2 간단한 펄 웹 서버 #   완전한 기능을 갖춘 HTTP 서버를 만들고자 한다면 50,000줄이 넘는 코드로 되어있고, 부가적인 처리 모듈들을 더 하면 훨씬 커진다. HTTP/1.1의 기능들을 지원하려면, 풍부한 리소스 지원, 가상 호스팅, 접근 제어, 로깅, 설정, 모니터링, 그 외 성능을 위한 기능 필요하다.  5.3 진짜 웹 서버가 하는 일 #   커넥션을 맺는다.  클라이언틔 접속을 받아들이거나, 원치 않은 클라이언트라면 닫는다.   요청을 받는다.  HTTP 요청 메시지를 네트워크로부터 읽어 들인다.   요청을 처리한다.  요청 메시지를 해석하고 행동을 취한다.   리소스에 접근한다.  메시지에서 지정한 리소스에 접근한다.   응답을 만든다.  올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.   응답을 보낸다.  응답을 클라이언트에게 돌려준다.   트랜잭션을 로그로 남긴다.  로그파일에 트랜잭션 오나료에 대한 기록을 남긴다.     5.4 단계 1: 클라이언트 커넥션 수락 #   클라이언트가 이미 서버에 대해 열려있는 지속적 커네겻을 갖고 있다면, 클라이언트는 요청을 보내기 위해 그 커넥션을 사용할 수 있다. 만약 가지고 있지 않다면, 클라이언트는 서버에 대한 새 커낵션을 열어야만 한다.  5.4.1 새 커넥션 다루기 #   클라이언트가 웹 서버에 TCP 커넥션을 요청하면, 웹 서버는 그 커넥션을 맺고 TCP 커넥션에서 IP 주소를 추출하여 커넥션 맞은편에 어떤 클라이언트가 있는지 확인한다. 새 커넥션이 맺어지면, 서버는 새 커넥션을 커넥션 목록에 추가하고 커넥션에서 오가는 데이터를 지켜보기 위한 준비를 한다. 웹 서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.  5.4.2 클라이언트 호스트 명 식별 #   대부분의 웹 서버는 역방향 DNS 를 사용해서 클라이언트의 IP 주소를 클라이언트의 호스트 명으로 변환화도록 설정되어 있다. 웹 서버는 클라이언트 호스트 명을 구체적인 접근 제어와 로깅을 위해 사용할 수 있다. 많은 대용량 웹 서버는 호스트 명 분석을 꺼두거나 특정 콘텐츠에 대해서만 켜놓는다.  5.4.3 ident를 통해 클라이언트 사용자 알아내기 #   ident 프로토콜은 서버에게 어떤 사용자 이름이 HTTP 커넥션을 초기화했는지 찾아낼 수 있게 해준다.  5.5 단계 2: 요청 메시지 수신 #   커넥션에 데이터가 도착하면, 웹 서버는 네트워크 커넥션에서 그 데이터를 읽어 들이고 파싱하여 요청 메시지를 구성한다. 요청 메시지를 파싱할 때, 웹서버는 아래와 같은 일을 한다.  요청줄을 파싱하여 요청 메소드, 지정된 리소스의 식별자, 버전 번호를 찾는다. 메시지 헤더들을 읽는다. (존재시)헤더의 끝을 의미하는 CRLF로 끝나는 빈 줄을 찾아낸다. 요청 본문이 있다면, 읽어 들인다.   요청 메시지를 파싱할 때, 웹 서버는 입력 데이터를 네트워크로부터 불규칙적으로 받는다. 네트워크 커넥션은 언제라도 끊길 수 있다.  5.5.1 메시지의 내부 표현 #   웹 서버는 요청 메시지를 쉽게 다룰 수 있도록 내부의 자료 구조에 저장한다.  5.5.2 커넥션 입력/출력 처리 아키텍쳐 #   공성능 웹 서버는 수천 개의 커넥션을 동시에 열 수 있도록 지원한다. 수천 개의 커넥션들은 웹 서버가 전 세계의 클라이언트들과 각각 한 개 이상의 커넥션을 통해 통신할 수 있게 한다. 웹 서버 아키텍처의 차이에 따라 요청을 처리하는 방식도 달라진다.    단일 스레드\n  한 번 요청에 하나씩 처리한다. 구현은 간단하지만 처리 도중에는 다른 모든 커넥션이 기다려야만 한다.   멀티 프로세스와 멀티 스레드\n  여러 요청을 동시 처리하기 위해 여러 개의 프로세스 혹은 고효율 스레드를 할당한다. 스레드/프로세스는 필요할 때마다 만들어질수도 있고, 미리 만들어 사용할 수도 있다. 스레드/프로세스가 너무 많아지면, 메모라니 시스 리소스를 소비하기 때문에 보통 최대 개수를 제한한다.   다중 I/O\n  다중 아키텍처에서는 모든 커넥션은 동시에 그 활동을 감시당한다. 어떤 커넥션의 상태가 바뀌면 그 커넥션에 대해 작은 양의 처리가 수행된다.   다중 멀티스레드\n  CPU 여러 개의 이점을 살리기 위해 멀티쓰레(b)와 다중화(c)를 결합한 것이다. 여러 개의 쓰레드(보통 하나의 물리적 프로세스)는 각각 열려있는 커넥션을 감시하고 각 커넥션에 대해 조금씩 작업을 수행한다.  5.6 단계3: 요청 처리 #   웹 서버가 요청을 받으면, 서버는 요청으로부터 메서드, 리소스, 헤더, 본문을 얻어내여 처리한다.  5.7 단계4: 리소스의 매핑과 접근 #   웹 서버는 리소스 서버이다. HTML 페이지나 JPED 이미지 같은 미리 만들어 진 콘텐츠를 제공하며, 서버 위에서 동작하는 리소스 생성 어플리케이션을 통해 만들어진 동적 컨텐츠도 제공한다. 웹 서버가 클라이언트에 콘텐츠를 전달하려면, 그전에 요청 메시지의 URI에 대응하는 알맞은 콘텐츠를 웹 서버에서 찾아서 그 콘텐츠의 원천을 식별해야 한다.  5.7.1 Docroot #   리소스 매핑의 가장 단순한 형태는 요청 URI를 웹 서버의 파일 시스템 안에 있는 파일 이름으로 사용하는 것이다. 웹 서버의 특별한 폴더를 웹 콘텐츠를 통해 예약해두는데, 이 폴더를 docroot이라고 부른다. 웹 서버 내부 설정에서 문서 루트를 설정 가능하다. 대부분의 웹 서버는 루트 위의 파일을 보려고 하는 URI를 허용하지 않는다.   가상 호스팅된 docroot\n  가상 호스팅 웹 서버는 각 사이트에 그들만의 분리된 문서 루트를 주는 방법으로 하나의 웹 서버에서 여러 개의 웹 사이트를 호스팅한다. 웹 서버는 URI나 Host 헤더에서 얻은 IP 주소나 호스트 명을 이용해서 올바른 문서 루트를 식별한다.   사용자 홈 디렉터리 docroots\n  사용자들이 한 대의 웹 서버에서 각자의 개인 웹사이트를 만들 수 있도록 해주는 경우도 있다. 보통 빗금(/)과 물결표(~) 다음에 사용자 이름이 오는 것으로 시작하는 URI는 그 사용자의 개인 docroot를 가리킨다.  5.7.2 디렉터리 목록 #   웹 서버는 경로가 파일이 아닌 디렉토리를 가리키는 URL에 대한 요청을 받을 수 있다. 대부분의 웹 서버는 클라이언트가 디렉터리 URL을 요청했을 때 다음과 같은 해동을 할 수 있다.  에러를 반환한다. 디렉터리 대신 특별한 파일을 반환한다. 디렉터리를 탐색해서 그 내용을 담은 HTML 페이지를 반환한다.    5.7.3 동적 콘텐츠 리소스 매핑 #   웹 서버는 URI를 동적 리소스에 매핑할 수 있다. 어떤 리소스가 동적 리소스라면, 어플리케이션 서버는 그에 대한 동적 콘텐츠 생성 프로그램이 어디에 있는지, 그리고 어떻게 그 프로그램을 실행하는지 알려줄 수 있어야 한다.  5.7.4 서버사이드 인클루드(Server-Side Includes, SSI) #   어떤 리소스가 서버사이드 인클루드를 포함하고 있는 것으로 설정되어 있다면, 서버는 그 리소스의 콘텐츠를 클라이언트에게 보내기 전에 처리한다.  5.7.5 접근 제어 #   웹 서버는 각각의 리소스에 접근 제어를 할당할 수 있다.  5.8 단계5: 응답 만들기 #   서버가 리소스를 식별하면, 서버는 요청 메서드로 서술되는 동작을 수행한 뒤 응답 메시지를 반환한다. 응답 메시지는 응답 상태 코드, 응답 헤더, 응답 본문을 포함한다.  5.8.1 응답 엔티티 #   만약 응답 본문이 있다면, 응답 메시지는 주로 다음을 포함한다.  응답 본문의 MIME 타입을 서술하는 Content-Type 헤더 응답 본문의 길이를 서술하는 Content-Length 헤더 실제 응답 본문의 내용    5.8.2 MIME 타입 결정하기 #   mime.types\n  웹 서버는 MIME 타입을 나타내기 위해 파일 이름의 확장자를 사용할 수 있다. 웹 서버는 각 리소스의 MIME 타입을 계산하기 위해 확장자별 MIME 타입이 담겨 있는 파일을 탐색한다.   매직 타이핑(Magic Typing)\n  파일 내용을 검사해서 알려진 패턴에 대한 테이블(매직 파일)에 해당하는 패턴이 있는지 찾아보는 방식이다. 속도가 느리긴 하지만 파일이 표준 확장자 없이 이름 지어진 경우에 사용하면 좋다.   유형 명시(Explicit Typing)\n  파일 확장자나 내용에 관계없이 어떤 MIME 타입을 갖도록 웹 서버가 지정하는 방식이다.   유형 협상(Type Negotiation)\n  어떤 웹 서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정할 수 있다.   5.8.3 리다이렉션 #   웹 서버는 종종 성공 메시지 대신 리다이렉션 응답을 반환한다. 웹 서버는 요청을 수행하기 위해 브라우저가 다른 곳으로 가도록 리다이렉트 할 수 있다.  5.9 단계6: 응답 보내기 #   웹 서버는 받을 때와 마찬가지로 커넥션 너머로 데이터를 보낼 때도 비슷한 이슈에 직면한다. 서버는 커넥션 상태를 추적해야 하며 지속적인 커넥션은 특별히 주의해야 한다. 비지속 커넥션  모든 메시지를 전송 후 서버 쪽에서 커넥션을 닫는다.   지속 커넥션  서버가 Content-Length 헤더를 바르게 계산하기 위해 특별한 주의를 필요로 하는 경우 또는 클라이언트가 응답이 언제 끝나는지 알 수 없는 경우에 커넥션을 유지한다.    5.10 단계7: 로깅 #   트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지에 대한 로그를 로그파일에 기록한다.  "}]